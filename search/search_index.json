{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#pynimate","title":"Pynimate","text":"<p>Python package for statistical data animations.</p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#with-pip","title":"with pip","text":"<p>You can install pynimate using <code>pip</code></p> <pre><code>pip install pynimate\n</code></pre>"},{"location":"#how-to-use","title":"How to use","text":"<p>Pynimate expects pandas dataframe formatted in this manner: Where the time column is set to index. <pre><code>time, col1, col2, col3\n2012   1     2     1\n2013   1     1     2\n2014   2     1.5   3\n2015   2.5   2     3.5\n</code></pre></p>"},{"location":"#bar-chart-example","title":"Bar Chart Example","text":"<pre><code>import pandas as pd\nfrom matplotlib import pyplot as plt\nimport pynimate as nim\ndf = pd.DataFrame(\n{\n\"time\": [\"1960-01-01\", \"1961-01-01\", \"1962-01-01\"],\n\"Afghanistan\": [1, 2, 3],\n\"Angola\": [2, 3, 4],\n\"Albania\": [1, 2, 5],\n\"USA\": [5, 3, 4],\n\"Argentina\": [1, 4, 5],\n}\n).set_index(\"time\")\ncnv = nim.Canvas()\nbar = nim.Barhplot.from_df(df, \"%Y-%m-%d\", \"2d\")\nbar.set_time(callback=lambda i, datafier: datafier.data.index[i].strftime(\"%b, %Y\"))\ncnv.add_plot(bar)\ncnv.animate()\nplt.show()\n</code></pre>"},{"location":"guide/dark_mode/","title":"Creating a dark themed bar chart race","text":""},{"location":"guide/dark_mode/#the-data","title":"The data","text":"<p>We will use the previous data for this animation</p> <pre><code>df = pd.DataFrame(\n{\n\"time\": [\"1960-01-01\", \"1961-01-01\", \"1962-01-01\"],\n\"Afghanistan\": [1, 2, 3],\n\"Angola\": [2, 3, 4],\n\"Albania\": [1, 2, 5],\n\"USA\": [5, 3, 4],\n\"Argentina\": [1, 4, 5],\n}\n).set_index(\"time\")\n</code></pre>"},{"location":"guide/dark_mode/#additional-variables","title":"Additional variables","text":"<p>There might be situations where we would like to show additional information for each column or date.  For instance in the previous data we would like to show continents of each country. In such cases use a Dataframe containing the additional variables in this format. <pre><code>columns,       continents\n\"Afghanistan\",  \"Asia\"\n\"Angola\",       \"Africa\"\n\"Albania\",      \"Europe\"\n\"USA\",          \"N America\"\n\"Argentina\"     \"S America\" \n</code></pre> This is a column-wise data where the index is the columns of the original data <pre><code>col_var = pd.DataFrame(\n{\n\"columns\": [\"Afghanistan\", \"Angola\", \"Albania\", \"USA\", \"Argentina\"],\n\"continent\": [\"Asia\", \"Africa\", \"Europe\", \"N America\", \"S America\"],\n}\n).set_index(\"columns\")\n</code></pre> Similarly we can use a row-wise data where the index is same as the original data. <pre><code>    time           leap-year var2   ...\n\"1960-01-01\"   \"yes\"     0\n\"1961-01-01\"   \"no\"      3\n\"1962-01-01\"   \"no\"      0\n</code></pre> use the <code>dfr.add_var(col_var=col_var)</code> module to add these dataframes.  </p>"},{"location":"guide/dark_mode/#post_update","title":"post_update","text":"<p><code>post_update(self, i)</code> is a function that runs for every frame.  It is very useful for extending  the basic animation. In this example we will use <code>post_update</code> to annotate continent names on bars. </p> <pre><code>def post_update(self, i):\n# annotates continents next to bars\nfor ind, (bar, x, y) in enumerate(\nzip(self.bar_attr.top_cols, self.bar_attr.bar_length, self.bar_attr.bar_rank)\n):\nself.ax.text(\nx - 0.3,\ny,\nself.dfr.col_var.loc[bar, \"continent\"],\nha=\"right\",\ncolor=\"k\",\nsize=12,\nzorder=ind,\n)\n</code></pre>"},{"location":"guide/dark_mode/#changing-colors","title":"Changing colors","text":"<p>All the text colors are set to white and the background color is made dark blue (\"#001219\").  <pre><code>...\nbar.set_title(\"Sample Title\", color=\"w\", weight=600)\nbar.set_xlabel(\"xlabel\", color=\"w\")\n...\n</code></pre> We have also manually set colors for each bar. <pre><code>bar_cols = {\n\"Afghanistan\": \"#2a9d8f\",\n\"Angola\": \"#e9c46a\",\n\"Albania\": \"#e76f51\",\n\"USA\": \"#a7c957\",\n\"Argentina\": \"#e5989b\",\n}\n</code></pre></p>"},{"location":"guide/dark_mode/#the-final-code","title":"The final code","text":"<pre><code>import os\nimport matplotlib as mpl\nimport numpy as np\nimport pandas as pd\nfrom matplotlib import pyplot as plt\nimport pynimate as nim\ndir_path = os.path.dirname(os.path.realpath(__file__))\nmpl.rcParams[\"axes.facecolor\"] = \"#001219\"\n# Turning off the spines\nfor side in [\"left\", \"right\", \"top\", \"bottom\"]:\nmpl.rcParams[f\"axes.spines.{side}\"] = False\ndef post_update(self, i):\n# annotates continents next to bars\nfor ind, (bar, x, y) in enumerate(\nzip(self.bar_attr.top_cols, self.bar_attr.bar_length, self.bar_attr.bar_rank)\n):\nself.ax.text(\nx - 0.3,\ny,\nself.dfr.col_var.loc[bar, \"continent\"],\nha=\"right\",\ncolor=\"k\",\nsize=12,\nzorder=ind,\n)\ndf = pd.read_csv(dir_path + \"/data/sample.csv\").set_index(\"time\")\ncol_var = pd.DataFrame(\n{\n\"columns\": [\"Afghanistan\", \"Angola\", \"Albania\", \"USA\", \"Argentina\"],\n\"continent\": [\"Asia\", \"Africa\", \"Europe\", \"N America\", \"S America\"],\n}\n).set_index(\"columns\")\nbar_cols = {\n\"Afghanistan\": \"#2a9d8f\",\n\"Angola\": \"#e9c46a\",\n\"Albania\": \"#e76f51\",\n\"USA\": \"#a7c957\",\n\"Argentina\": \"#e5989b\",\n}\ncnv = nim.Canvas(figsize=(12.8, 7.2), facecolor=\"#001219\")\ndfr = nim.BarDatafier(df, \"%Y-%m-%d\", \"3d\")\ndfr.add_var(col_var=col_var)\nbar = nim.Barhplot(dfr, post_update=post_update, rounded_edges=True, grid=False)\nbar.set_column_colors(bar_cols)\nbar.set_title(\"Sample Title\", color=\"w\", weight=600)\nbar.set_xlabel(\"xlabel\", color=\"w\")\nbar.set_time(\ncallback=lambda i, datafier: datafier.data.index[i].strftime(\"%b, %Y\"), color=\"w\"\n)\nbar.set_text(\n\"sum\",\ncallback=lambda i, datafier: f\"Total :{np.round(datafier.data.iloc[i].sum(), 2)}\",\nsize=20,\nx=0.72,\ny=0.20,\ncolor=\"w\",\n)\nbar.set_bar_annots(color=\"w\", size=13)\nbar.set_xticks(colors=\"w\", length=0, labelsize=13)\nbar.set_yticks(colors=\"w\", labelsize=13)\nbar.set_bar_border_props(\nedge_color=\"black\", pad=0.1, mutation_aspect=1, radius=0.2, mutation_scale=0.6\n)\ncnv.add_plot(bar)\ncnv.animate()\nplt.show()\n</code></pre>"},{"location":"guide/dark_mode/#result","title":"Result!","text":""},{"location":"guide/lineplot_darkmode/","title":"Creating a dark themed Animated Line plot","text":""},{"location":"guide/lineplot_darkmode/#the-data","title":"The data","text":"<p>We will be using Covid 19 data from kaggle by 'SRK and Devakumar K. P'. You can use the already cleaned data from examples/data/Covid_IN.</p> date cases cured 2020-03-28 185.0 13.0 2020-03-29 115.0 16.0 2020-03-30 181.0 6.0 2020-03-31 154.0 22.0 2020-04-01 475.0 20.0 2020-04-02 235.0 12.0 2020-04-03 401.0 10.0"},{"location":"guide/lineplot_darkmode/#theming","title":"Theming","text":"<p>Let us setup the colors for the lineplot. We will be using <code>#001219</code> as the canvas color. <pre><code>#Customizing matplotlib\nimport matplotlib as mpl\nfor side in [\"left\", \"right\", \"top\", \"bottom\"]:\nmpl.rcParams[f\"axes.spines.{side}\"] = False\nmpl.rcParams[\"figure.facecolor\"] = \"#001219\"\nmpl.rcParams[\"axes.facecolor\"] = \"#001219\"\nmpl.rcParams[\"savefig.facecolor\"] = \"#001219\"\n</code></pre> We will also set all text colors to white.   </p>"},{"location":"guide/lineplot_darkmode/#post_update","title":"post_update","text":"<p><code>post_update(self, i)</code> is a function that runs for every frame.  It is very useful for extending  the basic animation. In this example we will use <code>post_update</code> to format the xtick labels.  <code>human_readable</code> converts large numbers to human readable format.</p> <pre><code>def post(self, i):\nself.ax.yaxis.set_major_formatter(\ntick.FuncFormatter(lambda x, pos: human_readable(x))\n)\n</code></pre>"},{"location":"guide/lineplot_darkmode/#customizing-line-styles","title":"Customizing line styles","text":"<p>Use <code>.set_column_linestyles()</code> to set linestyles. We will set 'cases' to solid and 'cured' to dashed. <pre><code>#Linestyle defaults to solid\nplot.set_column_linestyles({\"cured\": \"dashed\"})\n</code></pre></p>"},{"location":"guide/lineplot_darkmode/#the-final-code","title":"The final code","text":"<p><pre><code>import os\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as tick\nimport pandas as pd\nimport pynimate as nim\nfrom pynimate.utils import human_readable\nfor side in [\"left\", \"right\", \"top\", \"bottom\"]:\nmpl.rcParams[f\"axes.spines.{side}\"] = False\nmpl.rcParams[\"figure.facecolor\"] = \"#001219\"\nmpl.rcParams[\"axes.facecolor\"] = \"#001219\"\nmpl.rcParams[\"savefig.facecolor\"] = \"#001219\"\ndir_path = os.path.dirname(os.path.realpath(__file__))\ndef post(self, i):\nself.ax.yaxis.set_major_formatter(\ntick.FuncFormatter(lambda x, pos: human_readable(x))\n)\ndf = pd.read_csv(dir_path + \"/data/covid_IN.csv\").set_index(\"time\")\ncnv = nim.Canvas()\ndfr = nim.LineDatafier(df, \"%Y-%m-%d\", \"12h\")\nplot = nim.Lineplot(\ndfr,\npost_update=post,\npalettes=[\"Set3\"],\nscatter_markers=False,\nlegend=True,\nfixed_ylim=True,\ngrid=False,\n)\nplot.set_column_linestyles({\"cured\": \"dashed\"})\nplot.set_title(\"Covid cases India(2021)\", y=1.05, color=\"w\", weight=600)\nplot.set_xlabel(\"xlabel\", color=\"w\")\nplot.set_time(\ncallback=lambda i, datafier: datafier.data.index[i].strftime(\"%d %b, %Y\"),\ncolor=\"w\",\nsize=15,\n)\nplot.set_line_annots(lambda col, val: f\"({human_readable(val)})\", color=\"w\")\nplot.set_legend(labelcolor=\"w\")\nplot.set_text(\n\"sum\",\ncallback=lambda i, datafier: f\"Total cases :{human_readable(datafier.data.cases.iloc[:i+1].sum() )}\",\nsize=10,\nx=0.8,\ny=0.20,\ncolor=\"w\",\n)\nplot.set_xticks(colors=\"w\", length=0, labelsize=10)\nplot.set_yticks(colors=\"w\", labelsize=10)\ncnv.add_plot(plot)\ncnv.animate()\ncnv.save(\"lineplot_dark\", 24)\nplt.show()\n</code></pre> (note: this gif has gone through some size and frame reduction, so you should get a better looking animation)</p>"},{"location":"guide/lineplot_darkmode/#result","title":"Result!","text":""},{"location":"guide/starter/","title":"Welcome to pynimate","text":"<p>Pynimate is a python package for statistical data animations.</p>"},{"location":"guide/starter/#installation","title":"Installation","text":""},{"location":"guide/starter/#with-pip","title":"with pip","text":"<p>You can install pynimate using <code>pip</code></p> <pre><code>pip install pynimate\n</code></pre>"},{"location":"guide/starter/#import","title":"Import","text":"<p>Pynimate is generally imported as <code>nim</code> and this convention is followed throughout the documentation. <pre><code>import pynimate as nim\n</code></pre></p>"},{"location":"guide/starter/#canvas","title":"Canvas","text":"<p>The Canvas class is used as a base for the animations, it handles the matplotlib figure, subplots as well as creating and saving animations.</p>"},{"location":"guide/starter/#basic-animations","title":"Basic Animations","text":"<p>We will go through some basic data animations using pynimate.</p>"},{"location":"guide/starter/#bar-chart-race","title":"Bar Chart Race","text":"<p>Create a Bar Chart Race using the <code>Barhplot</code> module.</p> <p>Pandas is a dependency and used for data manipulation, your data have to be a pandas <code>DataFrame</code>. The data needs to be in the following format, where the time column is set to index. <pre><code>time, col1, col2, col3\n2012   1     2     1\n2013   1     1     2\n2014   2     1.5   3\n2015   2.5   2     3.5\n</code></pre></p>"},{"location":"guide/starter/#pandas-setup","title":"Pandas setup","text":"<p>Use pandas to import your data and set the time column as index. <pre><code>import pandas as pd\ndf = pd.read_csv('data.csv').set_index('time')\n</code></pre></p> <p>Here is a sample data that we will work with. <pre><code>df = pd.DataFrame(\n{\n\"time\": [\"1960-01-01\", \"1961-01-01\", \"1962-01-01\"],\n\"Afghanistan\": [1, 2, 3],\n\"Angola\": [2, 3, 4],\n\"Albania\": [1, 2, 5],\n\"USA\": [5, 3, 4],\n\"Argentina\": [1, 4, 5],\n}\n).set_index(\"time\")\n</code></pre></p>"},{"location":"guide/starter/#datafiers","title":"Datafiers","text":"<p>Datafiers or Data Modifiers are helper modules that handles the data preparation part. The dafafier for Barhplot is BarDatafier</p>"},{"location":"guide/starter/#barhplot","title":"Barhplot","text":"<p>Barhplot can be initialized in two different ways either by passing the BarDatafier <pre><code>dfr = nim.BarDatafier(df, \"%Y-%m-%d\", \"2d\")  \nbar = nim.Barhplot(dfr)\n</code></pre> or by passing the pandas dataframe directly <pre><code>bar = nim.Barhplot.from_df(df, \"%Y-%m-%d\", \"2d\")\n</code></pre> In both case there are three required arguments.  </p> <p><code>data</code>: The data to be plotted and animated. <code>time_format</code>: The date-time format of the data index. In our case it is <code>\"%Y-%m-%d\"</code>. <code>ip_freq</code>: The interpolation frequency. Most data in their original form are not suitable for animations, Why? Lets understand the absolute basics of these animations. Consider this data: <pre><code>time, col1, col2\n2012   1     3  \n2013   2     2   \n2014   3     1\n</code></pre> This will yield three bar plots, one for each row. Now a typical video is of 24 fps, i.e every second consists of 24 frames. or in our case each second should consist of 24 images of static plots. So if we were to plot this, the video would be 3/24 second long.  </p> <p>This is where interpolation(Linear) comes to play, if we were to interpolate the data quarterly, The new data will be <pre><code>   time     col1  col2\n2012-01-01  1.00  3.00\n2012-04-01  1.25  2.75\n2012-07-01  1.50  2.50\n2012-10-01  1.75  2.25\n2013-01-01  2.00  2.00\n2013-04-01  2.25  1.75\n2013-07-01  2.50  1.50\n2013-10-01  2.75  1.25\n2014-01-01  3.00  1.00\n</code></pre> Now we have 9 rows, so our video will be 9/24 seconds long.</p> <p>In general you will be plotting a much larger data, so your video will be much larger. The interpolation is mostly used to make the video smooth.  </p> <p>You might wonder whether this interpolation will misrepresent the plot. Considering there is no way to know what the original values are between the actual intervals.  </p> <p>That is something for the user to decide. If your data is large enough, you wont need interpolation. In such case set <code>ip_freq = None</code>.</p> <p>Now that the fundamentals are discussed, use Barplot to create the animation. <pre><code># import matplotlib if you wish to see the animation in gui\nimport pandas as pd\nfrom matplotlib import pyplot as plt\nimport pynimate as nim\ndf = pd.DataFrame(\n{\n\"time\": [\"1960-01-01\", \"1961-01-01\", \"1962-01-01\"],\n\"Afghanistan\": [1, 2, 3],\n\"Angola\": [2, 3, 4],\n\"Albania\": [1, 2, 5],\n\"USA\": [5, 3, 4],\n\"Argentina\": [1, 4, 5],\n}\n).set_index(\"time\")\ncnv = nim.Canvas()\n# Interpolation frequency is 2 days\nbar = nim.Barhplot.from_df(df, \"%Y-%m-%d\", \"2d\")\n# use set_time to draw the datetime in the canvas\n# here we are using a callback that returns datetime formatted in month, year\nbar.set_time(callback=lambda i, datafier: datafier.data.index[i].strftime(\"%b, %Y\"))\n# add the bar plot to the canvas\ncnv.add_plot(bar)\ncnv.animate()\nplt.show()\n</code></pre></p>"},{"location":"guide/starter/#save-the-animation","title":"Save the animation","text":"<p>Use <code>Canvas.save()</code> to save the animation.</p>"},{"location":"guide/starter/#as-gif","title":"As GIF","text":"<p>Matplotlib uses pillow under the hood to save gifs, however you can use writer of your choice. <pre><code>cnv.save(\"file\", 24, \"gif\")\n</code></pre></p>"},{"location":"guide/starter/#as-mp4","title":"As mp4","text":"<p><code>ffmpeg</code> is a standard writer for saving as mp4 <pre><code>pip install ffmpeg-python\n</code></pre> or  <pre><code>conda install ffmpeg\n</code></pre> Use <code>Canvas.save()</code> to save the animation <pre><code>cnv.save(\"file\", 24 ,\"mp4\")\n</code></pre></p>"},{"location":"guide/starter/#result","title":"Result!","text":""},{"location":"reference/barhplot/","title":"Barhplot","text":"<p>See Baseplot for inherited modules.</p>"},{"location":"reference/barhplot/#barhplot_1","title":"Barhplot","text":"<p>             Bases: <code>Baseplot</code></p> <p>Bar Chart animation module that requires a valid time index.The data should be in this format where time is set to index     <pre><code>    Example:\n    &gt;&gt;&gt; time  col1 col2 col3 ...\n    &gt;&gt;&gt; 2012   1    0    2\n    &gt;&gt;&gt; 2013   2    3    1\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>datafier</code> <code>BarDatafier</code> <p>The datafier instance</p> required <code>palettes</code> <code>list[str]</code> <p>List of color palettes to generate bar colors, by default [\"viridis\"]</p> <code>['viridis']</code> <code>post_update</code> <code>Callable[[Barhplot, i], None]</code> <p>callback function for additional customization, by default lambda self, i: None</p> <code>lambda self, i: None</code> <code>annot_bars</code> <code>bool</code> <p>Sets bar annotations, by default True</p> <code>True</code> <code>fixed_xlim</code> <code>bool</code> <p>If False xlim will gradually change in every frame, by default True</p> <code>True</code> <code>xticks</code> <code>bool</code> <p>Sets xticks, by default True</p> <code>True</code> <code>yticks</code> <code>bool</code> <p>Sets yticks, by default True</p> <code>True</code> <code>grid</code> <code>bool</code> <p>Sets xgrid, by default True</p> <code>True</code> <code>rounded_edges</code> <code>bool</code> <p>Sets rounded bar edges, by default False</p> <code>False</code> <p>post_update args <pre><code>self: Baseplot instance\ni: Frame index\n\nexample:\n\n&gt;&gt;&gt; def post_update(self, i):\n&gt;&gt;&gt;     # sets log scale for x-axis\n&gt;&gt;&gt;     self.ax.set_xscale(\"log\")\n</code></pre></p>"},{"location":"reference/barhplot/#pynimate.barhplot.Barhplot.from_df","title":"<code>from_df(data, time_format, ip_freq, palettes=['viridis'], post_update=lambda self, i: None, annot_bars=True, rounded_edges=False, fixed_xlim=True, xticks=True, yticks=True, grid=True)</code>  <code>classmethod</code>","text":""},{"location":"reference/barhplot/#pynimate.barhplot.Barhplot.get_ith_bar_attrs","title":"<code>get_ith_bar_attrs(i)</code>","text":"<p>Prepares ith top columns and their respective attributes such as position, length, colors. Not meant to be used outside animation update.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>int</code> <p>Animation frame index</p> required <p>Returns:</p> Type Description <code>SimpleNamespace</code> <p>bar_rank, bar_length, top_cols, column_colors</p>"},{"location":"reference/barhplot/#pynimate.barhplot.Barhplot.set_xylim","title":"<code>set_xylim(xlim=[], ylim=[], xoffset=5, yoffset=0.6)</code>","text":"<p>Sets xlim and ylim.</p> <p>Parameters:</p> Name Type Description Default <code>xlim</code> <code>list[float]</code> <p>x axis limits in this format [min, max], by default [min, max + xoffset]</p> <code>[]</code> <code>ylim</code> <code>list[float]</code> <p>y axis limits in this format [min, max], by default [0.5, n_bars + yoffset]</p> <code>[]</code> <code>xoffset</code> <code>float</code> <p>additional offset value for x axis max, by default 5</p> <code>5</code> <code>yoffset</code> <code>float</code> <p>additional offset value for y axis max, by default 0.6</p> <code>0.6</code>"},{"location":"reference/barhplot/#pynimate.barhplot.Barhplot.set_barh","title":"<code>set_barh(bar_height=0.86, **kwargs)</code>","text":"<p>Sets barh properties, addition kwargs are passed to <code>ax.barh(**kwargs)</code></p> <p>Parameters:</p> Name Type Description Default <code>bar_height</code> <code>float</code> <p>Height of the bars (Note this is horizontal barplot), by default 0.86</p> <code>0.86</code>"},{"location":"reference/barhplot/#pynimate.barhplot.Barhplot.set_bar_annots","title":"<code>set_bar_annots(text_callback=lambda val: np.round(val, 2), xoffset=0.1, yoffset=-0.1, ha='left', **kwargs)</code>","text":"<p>Sets bar annotation properties, additional kwargs are passed to <code>ax.text(**kwargs)</code>. (Note these annotations are the texts near the bars)</p> <p>Parameters:</p> Name Type Description Default <code>text_callback</code> <code>Callable[[float], Union[str, float]]</code> <p>Callback function for customizing the text, by default lambda val:np.round(val, 2)</p> <code>lambda val: np.round(val, 2)</code> <code>xoffset</code> <code>float</code> <p>X offset relative to bar length, by default 0.1</p> <code>0.1</code> <code>yoffset</code> <code>float</code> <p>Y offset relative to bar height, by default -0.1</p> <code>-0.1</code> <code>ha</code> <code>str</code> <p>Horizontal alignment, by default \"left\"</p> <code>'left'</code>"},{"location":"reference/barhplot/#pynimate.barhplot.Barhplot.set_bar_border_props","title":"<code>set_bar_border_props(edge_color='k', radius=0.5, pad=-0.004, mutation_aspect=0.2, **kwargs)</code>","text":"<p>Sets bar border properties. Additional kwargs are passed to <code>FancyBboxPatch</code>. See https://matplotlib.org/3.1.0/api/_as_gen/matplotlib.patches.FancyBboxPatch.html</p> <p>Parameters:</p> Name Type Description Default <code>edge_color</code> <code>str</code> <p>Bar edge color, by default \"k\"</p> <code>'k'</code> <code>radius</code> <code>float</code> <p>Bar border radius, by default 0.5</p> <code>0.5</code> <code>pad</code> <code>float</code> <p>See above link, by default -0.0040</p> <code>-0.004</code> <code>mutation_aspect</code> <code>float</code> <p>See above link, by default 0.2</p> <code>0.2</code>"},{"location":"reference/barplot/","title":"Barplot","text":"<p>Barplot is deprecated, use barhplot instead.</p>"},{"location":"reference/barplot/#barplot_1","title":"Barplot","text":"<p>Barplot is deprecated, use Barhplot instead</p> <p>BarChartRace module that requires a valid time index.The data should be in this format where time is set to index     <pre><code>    Example:\n    &gt;&gt;&gt; time  col1 col2 col3 ...\n    &gt;&gt;&gt; 2012   1    0    2\n    &gt;&gt;&gt; 2013   2    3    1\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>pd.DataFrame</code> <p>The data to be prepared</p> required <code>time_format</code> <code>str</code> <p>Index datetime format</p> required <code>ip_freq</code> <code>str</code> <p>Interpolation frequency</p> required <code>ip_frac</code> <code>float</code> <p>Interpolation fraction (check end of docstring), by default 0.5</p> <code>0.5</code> <code>n_bars</code> <code>int</code> <p>Number of bars to be visible on the plot, by default 10 or less</p> <code>10</code> <code>palettes</code> <code>list[str]</code> <p>List of color palettes to generate bar colors, by default [\"viridis\"]</p> <code>['viridis']</code> <code>post_update</code> <code>Callable[[plt.Axes, int, Datafier, SimpleNamespace], None]</code> <p>callback function for additional customization, by default None</p> <code>None</code> <code>annot_bars</code> <code>bool</code> <p>Sets bar annotations, by default True</p> <code>True</code> <code>fixed_xlim</code> <code>bool</code> <p>If False xlim will gradually change in every frame, by default True</p> <code>True</code> <code>xticks</code> <code>bool</code> <p>Sets xticks, by default True</p> <code>True</code> <code>yticks</code> <code>bool</code> <p>Sets yticks, by default True</p> <code>True</code> <code>grid</code> <code>bool</code> <p>Sets xgrid, by default True</p> <code>True</code> <code>rounded_edges</code> <code>bool</code> <p>Sets rounded bar edges, by default False</p> <code>False</code> <p>post_update args: <pre><code>    plt.Axes: The matplotlib Axes used for the barplot\n    int: Current animation frame or dataframe row\n    Datafier: The underlying datafier instance\n    SimpleNamespace: Contains the following attributes -\n        bar_rank, bar_length, top_bars, bar_colors\n\nexample:\n\n&gt;&gt;&gt; def post_update(ax, i, datafier, bar_attr):\n&gt;&gt;&gt;     # sets log scale for x-axis\n&gt;&gt;&gt;     ax.set_xscale(\"log\")\n</code></pre> ip_frac description: <pre><code>    ip_frac is the percentage of NaN values to be linearly\n    interpolated for column ranks\n\n    Consider this example\n    &gt;&gt;&gt;               a    b\n    &gt;&gt;&gt; date\n    &gt;&gt;&gt; 2021-11-13  1.0  4.0\n    &gt;&gt;&gt; 2021-11-14  NaN  NaN\n    &gt;&gt;&gt; 2021-11-15  NaN  NaN\n    &gt;&gt;&gt; 2021-11-16  NaN  NaN\n    &gt;&gt;&gt; 2021-11-17  NaN  NaN\n    &gt;&gt;&gt; 2021-11-18  2.0  6.0\n\n    with ip_frac set to 0.5, 50% of NaN's will be linearly\n    interpolated while the rest will back filled.\n\n    &gt;&gt;&gt;              a      b\n    &gt;&gt;&gt; 2021-11-13  1.00  4.00  &lt;&lt; original value --------\n    &gt;&gt;&gt; 2021-11-14  1.33  4.67                            |\n    &gt;&gt;&gt; 2021-11-15  1.67  5.33                            |  50% linearly\n    &gt;&gt;&gt; 2021-11-16  2.00  6.00  &lt;- linear interpolation   |  interpolated\n    &gt;&gt;&gt; 2021-11-17  2.00  6.00      upto here             |  rest are filled.\n    &gt;&gt;&gt; 2021-11-18  2.00  6.00  &lt;&lt; original value---------\n\n    This adds some stability in the barChartRace\n    and reduces constantly shaking of bars.\n</code></pre></p>"},{"location":"reference/barplot/#pynimate.bar.Barplot.add_var","title":"<code>add_var(row_var=None, col_var=None)</code>","text":"<p>Adds additional variables to the data, both row and column wise.</p> <p>Row wise data format: The index should be equal to that of the actual data <pre><code>    time  leap_year col2   ...\n    2012    yes      0\n    2013    no       3\n</code></pre> Column wise data format: The index should be equal to the columns of the actual data. <pre><code>    index  continent   col2 ...\n    ind    Asia         0\n    usa    N America    3\n    jap    Asia         2\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>row_var</code> <code>pd.DataFrame</code> <p>Dataframe containing variables related to time, by default None</p> <code>None</code> <code>col_var</code> <code>pd.DataFrame</code> <p>Dataframe containing variables related to columns, by default None</p> <code>None</code>"},{"location":"reference/barplot/#pynimate.bar.Barplot.set_bar_color","title":"<code>set_bar_color(colors)</code>","text":"<p>If colors is a list, length of colors should be equal to no of <code>datafier.bar_colors</code>. If it is a dict, all columns of <code>datafier.top_cols</code> should be mapped to a color</p> <p>Parameters:</p> Name Type Description Default <code>colors</code> <code>Union[list, dict[str, str]]</code> <p>list of colors or dict of column to color mapping</p> required"},{"location":"reference/barplot/#pynimate.bar.Barplot.getTopXY","title":"<code>getTopXY(i)</code>","text":"<p>Prepares top n_bar columns and their respective attributes such as position, length, colors. Not meant to be used outside animation update</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>int</code> <p>Animation frame index</p> required <p>Returns:</p> Type Description <code>SimpleNamespace</code> <p>Bar rank, length. Top columns and their respective colors</p>"},{"location":"reference/barplot/#pynimate.bar.Barplot.set_xylim","title":"<code>set_xylim(xlim=[], ylim=[])</code>","text":"<p>Sets xlim and ylim</p> <p>Parameters:</p> Name Type Description Default <code>xlim</code> <code>list[float]</code> <p>x axis limits in this format [min, max], by default [min, max + 5]</p> <code>[]</code> <code>ylim</code> <code>list[float]</code> <p>y axis limits in this format [min, max], by default [0.5, n_bars + 0.6]</p> <code>[]</code>"},{"location":"reference/barplot/#pynimate.bar.Barplot.set_title","title":"<code>set_title(title, x=0, y=1.01, size=13, color='#777777', **kwargs)</code>","text":"<p>Sets the plot title and additional <code>kwargs</code> are passed to plt.text(**kwargs)</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title text</p> required <code>x</code> <code>float</code> <p>x coordinate of the text, by default 0</p> <code>0</code> <code>y</code> <code>float</code> <p>y coordinate, by default 1.01</p> <code>1.01</code> <code>size</code> <code>float</code> <p>text size, by default 13</p> <code>13</code> <code>color</code> <code>str</code> <p>text color, by default \"#777777\"</p> <code>'#777777'</code>"},{"location":"reference/barplot/#pynimate.bar.Barplot.set_xlabel","title":"<code>set_xlabel(text, x=0.43, y=-0.09, size=13, color='#777777', **kwargs)</code>","text":"<p>Sets the plot xlabel and additional <code>kwargs</code> are passed to plt.text(**kwargs)</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The xlabel text</p> required <code>x</code> <code>float</code> <p>X coordinate of the text, by default 0.43</p> <code>0.43</code> <code>y</code> <code>float</code> <p>Y coordinate, by default -0.09</p> <code>-0.09</code> <code>size</code> <code>float</code> <p>Text size, by default 13</p> <code>13</code> <code>color</code> <code>str</code> <p>Text color, by default \"#777777\"</p> <code>'#777777'</code>"},{"location":"reference/barplot/#pynimate.bar.Barplot.set_time","title":"<code>set_time(callback=lambda i, datafier: datafier.data.index[i], x=0.97, y=0.27, size=46, weight=800, ha='right', color='#777777', **kwargs)</code>","text":"<p>Annotates the time in the plot and additional <code>kwargs</code> are passed to plt.text(**kwargs)</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[int, pd.DataFrame], str]</code> <p>Callback function to customize the time text, by default <code>lambda i, datafier: datafier.data.index[i]</code></p> <code>lambda i, datafier: datafier.data.index[i]</code> <code>x</code> <code>float</code> <p>x coordinate of the text, by default 0.97</p> <code>0.97</code> <code>y</code> <code>float</code> <p>y coordinate of the text, by default 0.27</p> <code>0.27</code> <code>size</code> <code>float</code> <p>text size, by default 46</p> <code>46</code> <code>weight</code> <code>float</code> <p>text weight, by default 800</p> <code>800</code> <code>ha</code> <code>str</code> <p>horizontal alignment, by default \"right\"</p> <code>'right'</code> <code>color</code> <code>str</code> <p>text color, by default \"#777777\"</p> <code>'#777777'</code> <p>callback args: <pre><code>    i: Animation frame / data row index\n    datafier: The datafier instance,\n        access the data using datafier.data\n</code></pre></p>"},{"location":"reference/barplot/#pynimate.bar.Barplot.set_text","title":"<code>set_text(key, text=None, callback=None, x=0, y=0, size=13, color='#777777', **kwargs)</code>","text":"<p>General function to add custom texts in the plot. Either text or callback should be passd but not both.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Unique identifier for each texts, note: These keys, title, xlabel, time, are reserved.   overwrite them if you wish to use callbacks instead of texts in title or xlabel</p> required <code>text</code> <code>str</code> <p>The text to be added in the plot, by default None</p> <code>None</code> <code>callback</code> <code>Callable[[int, pd.DataFrame], str]</code> <p>Callback function to customize the text, by default None</p> <code>None</code> <code>x</code> <code>float</code> <p>X coordinate of the text, by default 0</p> <code>0</code> <code>y</code> <code>str</code> <p>Y coordinate of the text, by default 0</p> <code>0</code> <code>size</code> <code>float</code> <p>Text size, by default 13</p> <code>13</code> <code>color</code> <code>str</code> <p>Text color, by default \"#777777\"</p> <code>'#777777'</code> <p>Callback args: <pre><code>    args:\n    i: Animation frame / data row index\n    datafier: The datafier instance\n\n    Example:\n    &gt;&gt;&gt; lambda i, datafier: datafier.data.index[i]\n</code></pre></p>"},{"location":"reference/barplot/#pynimate.bar.Barplot.remove_text","title":"<code>remove_text(keys)</code>","text":"<p>Removes texts by key</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>list[str]</code> <p>List of keys to be removed</p> required"},{"location":"reference/barplot/#pynimate.bar.Barplot.set_bar_border_props","title":"<code>set_bar_border_props(edge_color='k', radius=0.5, pad=-0.004, mutation_aspect=0.2, **kwargs)</code>","text":"<p>Sets bar border properties. Additional <code>kwargs</code> are passed to FancyBboxPatch. See https://matplotlib.org/3.1.0/api/_as_gen/matplotlib.patches.FancyBboxPatch.html</p> <p>Parameters:</p> Name Type Description Default <code>edge_color</code> <code>str</code> <p>Bar edge color, by default \"k\"</p> <code>'k'</code> <code>radius</code> <code>float</code> <p>Bar border radius, by default 0.5</p> <code>0.5</code> <code>pad</code> <code>float</code> <p>See above link, by default -0.0040</p> <code>-0.004</code> <code>mutation_aspect</code> <code>float</code> <p>See above link, by default 0.2</p> <code>0.2</code>"},{"location":"reference/barplot/#pynimate.bar.Barplot.set_barh","title":"<code>set_barh(bar_height=0.86, **kwargs)</code>","text":"<p>Sets barh properties, addition <code>kwargs</code> are passed to ax.barh(**kwargs)</p> <p>Parameters:</p> Name Type Description Default <code>bar_height</code> <code>float</code> <p>Height of the bars (Note this is horizontal barplot), by default 0.86</p> <code>0.86</code>"},{"location":"reference/barplot/#pynimate.bar.Barplot.set_xticks","title":"<code>set_xticks(axis='x', colors='#777777', labelsize=12, **kwargs)</code>","text":"<p>Sets xtick properties, additional <code>kwargs</code> are passed to ax.tick_params(**.kwargs)</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>str</code> <p>Defines tick axis, by default \"x\"</p> <code>'x'</code> <code>colors</code> <code>str</code> <p>Sets tick color, by default \"#777777\"</p> <code>'#777777'</code> <code>labelsize</code> <code>float</code> <p>Sets tick size, by default 12</p> <code>12</code>"},{"location":"reference/barplot/#pynimate.bar.Barplot.set_yticks","title":"<code>set_yticks(axis='y', colors='#777777', labelsize=10, **kwargs)</code>","text":"<p>Sets ytick properties, additional <code>kwargs</code> are passed to ax.tick_params(**kwargs)</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>str</code> <p>Defines tick axis, by default \"y\"</p> <code>'y'</code> <code>colors</code> <code>str</code> <p>Sets tick color, by default \"#777777\"</p> <code>'#777777'</code> <code>labelsize</code> <code>float</code> <p>Sets tick size, by default 10</p> <code>10</code>"},{"location":"reference/barplot/#pynimate.bar.Barplot.set_grid","title":"<code>set_grid(which='major', axis='x', linestyle='-', grid_behind=True, **kwargs)</code>","text":"<p>Sets the plots grid, additional <code>kwargs</code> are passed to ax.grid(**kwargs)</p> <p>Parameters:</p> Name Type Description Default <code>which</code> <code>str</code> <p>The grid lines to apply the changes on, by default \"major\"</p> <code>'major'</code> <code>axis</code> <code>str</code> <p>Sets the axis of the grid, by default \"x\"</p> <code>'x'</code> <code>linestyle</code> <code>str</code> <p>Grids line style, by default \"-\"</p> <code>'-'</code> <code>grid_behind</code> <code>bool</code> <p>Sets the grid behind the bars, by default True</p> <code>True</code>"},{"location":"reference/barplot/#pynimate.bar.Barplot.set_bar_annots","title":"<code>set_bar_annots(text_callback=lambda val: np.round(val, 2), xoffset=0.1, yoffset=-0.1, ha='left', **kwargs)</code>","text":"<p>Sets bar annotation properties, additional kwargs are passed to <code>ax.text(**kwargs)</code>. (Note these annotations are the texts near the bars)</p> <p>Parameters:</p> Name Type Description Default <code>text_callback</code> <code>Callable[[float], Union[str, float]]</code> <p>Callback function for customizing the text, by default lambda val:np.round(val, 2)</p> <code>lambda val: np.round(val, 2)</code> <code>xoffset</code> <code>float</code> <p>X offset relative to bar length, by default 0.1</p> <code>0.1</code> <code>yoffset</code> <code>float</code> <p>Y offset relative to bar height, by default -0.1</p> <code>-0.1</code> <code>ha</code> <code>str</code> <p>Horizontal alignment, by default \"left\"</p> <code>'left'</code>"},{"location":"reference/barplot/#pynimate.bar.Barplot.add_extras","title":"<code>add_extras(key, callback)</code>","text":"<p>Adds extra callback functions for additional customizations</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Unique identifier for each callback function</p> required <code>callback</code> <code>list[Callable[[plt.Axes, int, pd.DataFrame, pd.DataFrame], None]]</code> <p>Callback function for additional customization</p> required <p>Callback args: <pre><code>    plt.Axes: The matplotlib Axes used for the barplot\n    int: Current animation frame / dataframe row\n    Datafier: The underlying datafier instance\n    SimpleNamespace: Contains the following attributes -\n    bar_rank, bar_length, top_bars, bar_colors\n\n    Example:\n    &gt;&gt;&gt; lambda ax, *args: ax.set_xcale(\"log)\n</code></pre></p>"},{"location":"reference/baseplot/","title":"Baseplot","text":""},{"location":"reference/baseplot/#baseplot_1","title":"Baseplot","text":"<p>General Chart animation module that requires a valid time index.The data should be in this format where time is set to index     <pre><code>    Example:\n    &gt;&gt;&gt; time  col1 col2 col3 ...\n    &gt;&gt;&gt; 2012   1    0    2\n    &gt;&gt;&gt; 2013   2    3    1\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>datafier</code> <code>BaseDatafier</code> <p>The datafier instance</p> required <code>palettes</code> <code>list[str]</code> <p>List of color palettes to generate bar colors, by default [\"viridis\"]</p> <code>['viridis']</code> <code>post_update</code> <code>Callable[[Baseplot, i], None]</code> <p>callback function for additional customization, by default lambda self, i: None</p> <code>lambda self, i: None</code> <code>fixed_xlim</code> <code>bool</code> <p>If False xlim will gradually change in every frame, by default True</p> <code>True</code> <code>fixed_ylim</code> <code>bool</code> <p>If False ylim will gradually change in every frame, by default True</p> <code>True</code> <code>xticks</code> <code>bool</code> <p>Sets xticks, by default True</p> <code>True</code> <code>yticks</code> <code>bool</code> <p>Sets yticks, by default True</p> <code>True</code> <code>grid</code> <code>bool</code> <p>Sets xgrid, by default True</p> <code>True</code> <p>post_update args <pre><code>    self: Baseplot instance\n    i: Frame index\n\nexample:\n\n&gt;&gt;&gt; def post_update(self, i):\n&gt;&gt;&gt;     # sets log scale for x-axis\n&gt;&gt;&gt;     self.ax.set_xscale(\"log\")\n</code></pre></p>"},{"location":"reference/baseplot/#pynimate.baseplot.Baseplot.from_df","title":"<code>from_df(data, time_format, ip_freq, palettes=['viridis'], post_update=lambda self, i: None, fixed_xlim=True, fixed_ylim=True, xticks=True, yticks=True, grid=True)</code>  <code>classmethod</code>","text":""},{"location":"reference/baseplot/#pynimate.baseplot.Baseplot.generate_column_colors","title":"<code>generate_column_colors()</code>","text":"<p>Generates column colors based on the given color palettes.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict containing column to color mapping</p>"},{"location":"reference/baseplot/#pynimate.baseplot.Baseplot.set_column_colors","title":"<code>set_column_colors(colors)</code>","text":"<p>Sets column colors. If colors is a list, length of colors should be equal to <code>len(column_colors)</code></p> <p>Parameters:</p> Name Type Description Default <code>colors</code> <code>Union[str, list[str], dict[str, str]]</code> <p>Single color str or list of colors or dict of column to color mapping</p> required"},{"location":"reference/baseplot/#pynimate.baseplot.Baseplot.set_xylim","title":"<code>set_xylim(xlim=[], ylim=[])</code>","text":"<p>Sets xlim and ylim</p> <p>Parameters:</p> Name Type Description Default <code>xlim</code> <code>list[float]</code> <p>x axis limits in this format [min, max], by default [min date, max date]</p> <code>[]</code> <code>ylim</code> <code>list[float]</code> <p>y axis limits in this format [min, max], by default [min y val, max y val]</p> <code>[]</code>"},{"location":"reference/baseplot/#pynimate.baseplot.Baseplot.set_title","title":"<code>set_title(title, x=0, y=1.01, size=13, color='#777777', **kwargs)</code>","text":"<p>Sets the plot title and additional kwargs are passed to <code>plt.text(**kwargs)</code></p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title text</p> required <code>x</code> <code>float</code> <p>x coordinate of the text, by default 0</p> <code>0</code> <code>y</code> <code>float</code> <p>y coordinate, by default 1.01</p> <code>1.01</code> <code>size</code> <code>float</code> <p>text size, by default 13</p> <code>13</code> <code>color</code> <code>str</code> <p>text color, by default \"#777777\"</p> <code>'#777777'</code>"},{"location":"reference/baseplot/#pynimate.baseplot.Baseplot.set_xlabel","title":"<code>set_xlabel(text, x=0.43, y=-0.09, size=13, color='#777777', **kwargs)</code>","text":"<p>Sets the plot xlabel and additional kwargs are passed to <code>plt.text(**kwargs)</code></p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The xlabel text</p> required <code>x</code> <code>float</code> <p>X coordinate of the text, by default 0.43</p> <code>0.43</code> <code>y</code> <code>float</code> <p>Y coordinate, by default -0.09</p> <code>-0.09</code> <code>size</code> <code>float</code> <p>Text size, by default 13</p> <code>13</code> <code>color</code> <code>str</code> <p>Text color, by default \"#777777\"</p> <code>'#777777'</code>"},{"location":"reference/baseplot/#pynimate.baseplot.Baseplot.set_time","title":"<code>set_time(callback=lambda i, datafier: datafier.data.index[i], x=0.97, y=0.27, size=46, weight=800, ha='right', color='#777777', **kwargs)</code>","text":"<p>Annotates the time in the plot and additional kwargs are passed to <code>plt.text(**kwargs)</code></p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[int, BaseDatafier], str]</code> <p>Callback function to customize the time text, by default <code>lambda i, datafier: datafier.data.index[i]</code></p> <code>lambda i, datafier: datafier.data.index[i]</code> <code>x</code> <code>float</code> <p>x coordinate of the text, by default 0.97</p> <code>0.97</code> <code>y</code> <code>float</code> <p>y coordinate of the text, by default 0.27</p> <code>0.27</code> <code>size</code> <code>float</code> <p>text size, by default 46</p> <code>46</code> <code>weight</code> <code>float</code> <p>text weight, by default 800</p> <code>800</code> <code>ha</code> <code>str</code> <p>horizontal alignment, by default \"right\"</p> <code>'right'</code> <code>color</code> <code>str</code> <p>text color, by default \"#777777\"</p> <code>'#777777'</code> <p>callback args: <pre><code>    i: Animation frame / data row index\n    datafier: The datafier instance,\n        access the data using datafier.data\n</code></pre></p>"},{"location":"reference/baseplot/#pynimate.baseplot.Baseplot.set_text","title":"<code>set_text(key, text=None, callback=None, x=0, y=0, size=13, color='#777777', **kwargs)</code>","text":"<p>General function to add custom texts in the plot. Either text or callback should be passd but not both.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Unique identifier for each texts, note: These keys, title, xlabel, time, are reserved.   overwrite them if you wish to use callbacks instead of texts in title or xlabel</p> required <code>text</code> <code>str</code> <p>The text to be added in the plot, by default None</p> <code>None</code> <code>callback</code> <code>Callable[[int, pd.DataFrame], str]</code> <p>Callback function to customize the text, by default None</p> <code>None</code> <code>x</code> <code>float</code> <p>X coordinate of the text, by default 0</p> <code>0</code> <code>y</code> <code>str</code> <p>Y coordinate of the text, by default 0</p> <code>0</code> <code>size</code> <code>float</code> <p>Text size, by default 13</p> <code>13</code> <code>color</code> <code>str</code> <p>Text color, by default \"#777777\"</p> <code>'#777777'</code> <p>Callback args: <pre><code>    args:\n    i: Animation frame / data row index\n    datafier: The datafier instance\n\n    Example:\n    &gt;&gt;&gt; lambda i, datafier: datafier.data.index[i]\n</code></pre></p>"},{"location":"reference/baseplot/#pynimate.baseplot.Baseplot.remove_text","title":"<code>remove_text(keys)</code>","text":"<p>Removes texts by key</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>list[str]</code> <p>key or List of keys to be removed</p> required"},{"location":"reference/baseplot/#pynimate.baseplot.Baseplot.set_xticks","title":"<code>set_xticks(axis='x', colors='#777777', labelsize=12, **kwargs)</code>","text":"<p>Sets xtick properties, additional kwargs are passed to <code>ax.tick_params(**kwargs)</code></p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>str</code> <p>Defines tick axis, by default \"x\"</p> <code>'x'</code> <code>colors</code> <code>str</code> <p>Sets tick color, by default \"#777777\"</p> <code>'#777777'</code> <code>labelsize</code> <code>float</code> <p>Sets tick size, by default 12</p> <code>12</code>"},{"location":"reference/baseplot/#pynimate.baseplot.Baseplot.set_yticks","title":"<code>set_yticks(axis='y', colors='#777777', labelsize=10, **kwargs)</code>","text":"<p>Sets ytick properties, additional kwargs are passed to <code>ax.tick_params(**kwargs)</code></p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>str</code> <p>Defines tick axis, by default \"y\"</p> <code>'y'</code> <code>colors</code> <code>str</code> <p>Sets tick color, by default \"#777777\"</p> <code>'#777777'</code> <code>labelsize</code> <code>float</code> <p>Sets tick size, by default 10</p> <code>10</code>"},{"location":"reference/baseplot/#pynimate.baseplot.Baseplot.set_grid","title":"<code>set_grid(which='major', axis='x', linestyle='-', grid_behind=True, **kwargs)</code>","text":"<p>Sets the plots grid, additional kwargs are passed to <code>ax.grid(**kwargs)</code></p> <p>Parameters:</p> Name Type Description Default <code>which</code> <code>str</code> <p>The grid lines to apply the changes on, by default \"major\"</p> <code>'major'</code> <code>axis</code> <code>str</code> <p>Sets the axis of the grid, by default \"x\"</p> <code>'x'</code> <code>linestyle</code> <code>str</code> <p>Grids line style, by default \"-\"</p> <code>'-'</code> <code>grid_behind</code> <code>bool</code> <p>Sets the grid behind the plot, by default True</p> <code>True</code>"},{"location":"reference/canvas/","title":"Canvas","text":""},{"location":"reference/canvas/#canvas_1","title":"Canvas","text":"<p>Creates the matplotlib figure, subplots and additional figure properties. Also creates and saves the animation.</p> <p>Parameters:</p> Name Type Description Default <code>nrows</code> <code>int</code> <p>Number of rows of the subplot grid, by default 1</p> <code>1</code> <code>ncols</code> <code>int</code> <p>Number of columns of the subplot grid, by default 1</p> <code>1</code> <code>figsize</code> <code>tuple[int, int]</code> <p>Width, height in inches, by default (16, 9)</p> <code>(12.8, 7.2)</code> <code>post_update</code> <code>Callable[[plt.Figure, list[list[plt.Axes]]], None]</code> <p>callback function for additional figure customization, by default None</p> <code>None</code> <p>post_update args: <pre><code>    plt.Figure: Matplotlib figure\n    list[list[plt.Axes]]]: Subplot Axes\n</code></pre></p>"},{"location":"reference/canvas/#pynimate.canvas.Canvas.add_plot","title":"<code>add_plot(plot, index=(0, 0))</code>","text":"<p>Adds the plot to be animated with its ax index (for multiple subplots)</p> <p>Parameters:</p> Name Type Description Default <code>plot</code> <code>Plot_like</code> <p>Plot to be animated</p> required <code>index</code> <code>tuple[int, int]</code> <p>Subplot index, by default (0, 0)</p> <code>(0, 0)</code> <p>Returns:</p> Type Description <code>Canvas</code> <p>Returns the canvas instance</p>"},{"location":"reference/canvas/#pynimate.canvas.Canvas.animate","title":"<code>animate(frames_callback=lambda length: length, interval=50, **kwargs)</code>","text":"<p>Main module to create the animation, additional <code>kwargs</code> are passed to animation.FuncAnimation(**kwargs)</p> <p>Parameters:</p> Name Type Description Default <code>frames_callback</code> <code>int</code> <p>Passed to funcAnimation frames, by default lambda length: length</p> <code>lambda length: length</code> <code>interval</code> <code>int</code> <p>Interval between each frame. Defaults to 50ms, by default 50</p> <code>50</code>"},{"location":"reference/canvas/#pynimate.canvas.Canvas.save","title":"<code>save(filename, fps, extension='gif', **kwargs)</code>","text":"<p>Saves the current animation</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Filename</p> required <code>fps</code> <code>int</code> <p>Video fps / frames per second</p> required <code>extension</code> <code>str</code> <p>File extension, by default \"gif\"</p> <code>'gif'</code>"},{"location":"reference/lineplot/","title":"Lineplot","text":"<p>See Baseplot for inherited modules.</p>"},{"location":"reference/lineplot/#lineplot_1","title":"Lineplot","text":"<p>             Bases: <code>Baseplot</code></p> <p>Lineplot animation module that requires a valid time index.The data should be in this format where time is set to index     <pre><code>    Example:\n    &gt;&gt;&gt; time  col1 col2 col3 ...\n    &gt;&gt;&gt; 2012   1    0    2\n    &gt;&gt;&gt; 2013   2    3    1\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>datafier</code> <code>LineDatafier</code> <p>The datafier instance</p> required <code>palettes</code> <code>list[str]</code> <p>List of color palettes to generate line / marker colors, by default [\"viridis\"]</p> <code>['viridis']</code> <code>post_update</code> <code>Callable[[__qualname__, int], None]</code> <p>callback function for additional customization, by default lambda self, i: None</p> <code>lambda self, i: None</code> <code>line_annots</code> <code>bool</code> <p>Sets line annotations leading the lines, by default True</p> <code>True</code> <code>legend</code> <code>bool</code> <p>Sets plot legend, by default True</p> <code>True</code> <code>scatter_markers</code> <code>bool</code> <p>Enables line markers / Scatterplot, by default True</p> <code>True</code> <code>line_head</code> <code>bool</code> <p>Enables markers leading every line, by default True</p> <code>True</code> <code>fixed_xlim</code> <code>bool</code> <p>If False xlim will gradually change in every frame, by default True</p> <code>True</code> <code>fixed_ylim</code> <code>bool</code> <p>If False ylim will gradually change in every frame, by default False</p> <code>False</code> <code>xticks</code> <code>bool</code> <p>Sets xticks, by default True</p> <code>True</code> <code>yticks</code> <code>bool</code> <p>Sets yticks, by default True</p> <code>True</code> <code>grid</code> <code>bool</code> <p>Sets xgrid, by default True</p> <code>True</code>"},{"location":"reference/lineplot/#pynimate.lineplot.Lineplot.from_df","title":"<code>from_df(data, time_format, ip_freq, palettes=['viridis'], post_update=lambda self, i: None, line_annots=True, legend=True, scatter_markers=True, line_head=True, fixed_xlim=True, fixed_ylim=False, xticks=True, yticks=True, grid=True)</code>  <code>classmethod</code>","text":""},{"location":"reference/lineplot/#pynimate.lineplot.Lineplot.set_column_linestyles","title":"<code>set_column_linestyles(linestyles)</code>","text":"<p>Sets column linestyles. If linestyles is a list, length of linestyles should be equal to <code>len(self.column_linestyles)</code></p> <p>Parameters:</p> Name Type Description Default <code>linestyles</code> <code>Union[str, list[str], dict[str, str]]</code> <p>Single linestyle str or list of linestyles or dict of column to linestyle mapping</p> required"},{"location":"reference/lineplot/#pynimate.lineplot.Lineplot.set_line","title":"<code>set_line(**kwargs)</code>","text":"<p>Sets line properties, addition kwargs are passed to <code>ax.plot(**kwargs)</code></p>"},{"location":"reference/lineplot/#pynimate.lineplot.Lineplot.set_line_annots","title":"<code>set_line_annots(callback=lambda col, val: f'{col}({human_readable(val)})', size=10, **kwargs)</code>","text":"<p>Sets line annotation properties, additional kwargs are passed to <code>ax.text(**kwargs)</code>. (Note these annotations are the texts leading the lines)</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[str, float], str]</code> <p>Callback function for customizing the text, by default lambda col, val: f\"{col}({human_readable(val)})\"</p> <code>lambda col, val: f'{col}({human_readable(val)})'</code> <code>size</code> <code>float</code> <p>Text size, by default 10</p> <code>10</code>"},{"location":"reference/lineplot/#pynimate.lineplot.Lineplot.set_line_head","title":"<code>set_line_head(edgecolors='k', **kwargs)</code>","text":"<p>Sets the line head(leading marker) properites, additional kwargs are passed to <code>ax.scatter(**kwargs)</code></p> <p>Parameters:</p> Name Type Description Default <code>edgecolors</code> <code>Union[str, list[str]]</code> <p>Edge color of the point, by default \"k\"</p> <code>'k'</code>"},{"location":"reference/lineplot/#pynimate.lineplot.Lineplot.set_marker","title":"<code>set_marker(**kwargs)</code>","text":"<p>Sets the line marker (scatterplot) properties, kwargs are passed to <code>ax.scatter(**kwargs)</code></p>"},{"location":"reference/lineplot/#pynimate.lineplot.Lineplot.set_legend","title":"<code>set_legend(**kwargs)</code>","text":"<p>Sets legend properties, kwargs are passed to <code>ax.legend(**kwargs)</code></p>"},{"location":"reference/utils/","title":"Helper Functions","text":""},{"location":"reference/utils/#utils","title":"Utils","text":""},{"location":"reference/utils/#pynimate.utils.human_readable","title":"<code>human_readable(num, precision=2, *args)</code>","text":"<p>Converts large numeric values(&gt;10^3) into human readable strings. <code>ie. 1000 -&gt; 1k</code>, <code>1000000 -&gt; 1M</code>, etc.</p> <p>Parameters:</p> Name Type Description Default <code>num</code> <code>Union[float, int]</code> <p>Numeric value</p> required <code>precision</code> <code>int</code> <p>Rounding precision, by default 2</p> <code>2</code> <p>Returns:</p> Type Description <code>str</code> <p>Human readable numeric string</p>"},{"location":"reference/datafiers/bar_datafier/","title":"BarDatafier","text":""},{"location":"reference/datafiers/bar_datafier/#bardatafier_1","title":"BarDatafier","text":"<p>             Bases: <code>BaseDatafier</code></p> <p>Contains data preparation modules, which includes interpolation, rank generation. data should be in this format where time is set to index <pre><code>    Example:\n    &gt;&gt;&gt; time  col1 col2 col3 ...\n    &gt;&gt;&gt; 2012   1    0    2\n    &gt;&gt;&gt; 2013   2    3    1\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>pd.DataFrame</code> <p>The data to be prepared, should be in this format where time is set to index</p> required <code>time_format</code> <code>str</code> <p>Index datetime format</p> required <code>ip_freq</code> <code>str</code> <p>Interpolation frequency</p> required <code>ip_frac</code> <code>float</code> <p>Rank interpolation fraction (check end of docstring), by default 0.5</p> <code>0.1</code> <code>n_bars</code> <code>int</code> <p>Number of bars to be visible on the plot, by default 10 or less</p> <code>10</code> <code>ip_method</code> <code>str</code> <p>Interpolation Method, by default \"linear\"</p> <code>'linear'</code> <code>ip_fill_method</code> <code>str</code> <p>fill method for ip_frac, by default \"bfill\"</p> <code>'bfill'</code> <p>ip_frac is the percentage of NaN values to be linearly interpolated for column ranks</p> <p><pre><code>    Consider this example\n    &gt;&gt;&gt;               a    b\n    &gt;&gt;&gt; date\n    &gt;&gt;&gt; 2021-11-13  1.0  4.0\n    &gt;&gt;&gt; 2021-11-14  NaN  NaN\n    &gt;&gt;&gt; 2021-11-15  NaN  NaN\n    &gt;&gt;&gt; 2021-11-16  NaN  NaN\n    &gt;&gt;&gt; 2021-11-17  NaN  NaN\n    &gt;&gt;&gt; 2021-11-18  2.0  6.0\n</code></pre> with ip_frac set to 0.5, 50% of NaN's will be interpolated by ip_method while the rest will be filled by ip_fill_method. The example uses bfill, if ffill is used the filling will happen before interpolation. <pre><code>    &gt;&gt;&gt;              a      b\n    &gt;&gt;&gt; 2021-11-13  1.00  4.00  &lt;&lt; original value --------\n    &gt;&gt;&gt; 2021-11-14  1.33  4.67                            |\n    &gt;&gt;&gt; 2021-11-15  1.67  5.33                            |  50% interpolated\n    &gt;&gt;&gt; 2021-11-16  2.00  6.00  &lt;- linear interpolation   |  by ip_method\n    &gt;&gt;&gt; 2021-11-17  2.00  6.00      upto here             |  rest are filled\n    &gt;&gt;&gt; 2021-11-18  2.00  6.00  &lt;&lt; original value---------   by ip_fill_method\n</code></pre> This adds stability in the barChartRace and reduces constant shaking of bars.</p>"},{"location":"reference/datafiers/bar_datafier/#pynimate.datafier.BarDatafier.get_data_ranks","title":"<code>get_data_ranks(ip_frac=0.1)</code>","text":"<p>Creates column ranks and interpolates them.</p> <p>Parameters:</p> Name Type Description Default <code>ip_frac</code> <code>float</code> <p>pct of NaNs to interpolate by 'self.method' rest will be backfilled, by default 0.1</p> <code>0.1</code> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>Interpolated column ranks</p>"},{"location":"reference/datafiers/bar_datafier/#pynimate.datafier.BarDatafier.get_top_cols","title":"<code>get_top_cols()</code>","text":"<p>Selects columns where column_rank &lt; n_bars in any timestamp</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of columns that will appear in the animation at least once</p>"},{"location":"reference/datafiers/base_datafier/","title":"BaseDatafier","text":""},{"location":"reference/datafiers/base_datafier/#basedatafier_1","title":"BaseDatafier","text":"<p>Contains data preparation modules, which includes interpolation. data should be in this format where time is set to index <pre><code>    Example:\n    &gt;&gt;&gt; time  col1 col2 col3 ...\n    &gt;&gt;&gt; 2012   1    0    2\n    &gt;&gt;&gt; 2013   2    3    1\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>pd.DataFrame</code> <p>The data to be prepared, should be in this format where time is set to index</p> required <code>time_format</code> <code>str</code> <p>Index datetime format</p> required <code>ip_freq</code> <code>str</code> <p>Interpolation frequency</p> required"},{"location":"reference/datafiers/base_datafier/#pynimate.datafier.BaseDatafier.add_var","title":"<code>add_var(row_var=None, col_var=None)</code>","text":"<p>Adds additional variables to the data, both row and column wise.</p> <p>Row wise data format: The index should be equal to that of the actual data. <pre><code>    time  leap_year col2   ...\n    2012    yes      0\n    2013    no       3\n</code></pre> Column wise data format: The index should be equal to the columns of the actual data. <pre><code>    index  continent   col2 ...\n    ind    Asia         0\n    usa    N America    3\n    jap    Asia         2\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>row_var</code> <code>pd.DataFrame</code> <p>Dataframe containing variables related to time, by default None</p> <code>None</code> <code>col_var</code> <code>pd.DataFrame</code> <p>Dataframe containing variables related to columns, by default None</p> <code>None</code>"},{"location":"reference/datafiers/base_datafier/#pynimate.datafier.BaseDatafier.interpolate_even","title":"<code>interpolate_even(data, freq, method='linear')</code>","text":"<p>Interpolates the given dataframe according to the frequency</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>pd.DataFrame</code> <p>Dataframe containing the data</p> required <code>freq</code> <code>str</code> <p>Interpolation frequency</p> required <code>method</code> <code>str</code> <p>Interpolation method, by default \"linear\"</p> <code>'linear'</code> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>Interpolated dataframe</p>"},{"location":"reference/datafiers/base_datafier/#pynimate.datafier.BaseDatafier.interpolate_data","title":"<code>interpolate_data()</code>","text":"<p>Interpolates the raw data</p> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>Interpolated data</p>"},{"location":"reference/datafiers/datafier/","title":"Datafier","text":"<p>Datafier is deprecated, use plot specific datafiers instead.</p>"},{"location":"reference/datafiers/datafier/#datafier_1","title":"Datafier","text":"<p>Datafier is deprecated, use plot specific datafiers instead.</p> <p>Contains data preparation modules, which includes interpolation, rank generation, color_generation. data should be in this format where time is set to index <pre><code>    Example:\n    &gt;&gt;&gt; time  col1 col2 col3 ...\n    &gt;&gt;&gt; 2012   1    0    2\n    &gt;&gt;&gt; 2013   2    3    1\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>pd.DataFrame</code> <p>The data to be prepared, should be in this format where time is set to index</p> required <code>time_format</code> <code>str</code> <p>Index datetime format</p> required <code>ip_freq</code> <code>str</code> <p>Interpolation frequency</p> required <code>ip_frac</code> <code>float</code> <p>Rank interpolation fraction (check end of docstring), by default 0.5</p> <code>0.5</code> <code>n_bars</code> <code>int</code> <p>Number of bars to be visible on the plot, by default 10 or less</p> <code>10</code> <code>palettes</code> <code>list[str]</code> <p>List of color palettes to generate bar colors, by default [\"viridis\"]</p> <code>['viridis']</code> <pre><code>    ip_frac is the percentage of NaN values to be linearly\n    interpolated for column ranks\n\n    Consider this example\n    &gt;&gt;&gt;               a    b\n    &gt;&gt;&gt; date\n    &gt;&gt;&gt; 2021-11-13  1.0  4.0\n    &gt;&gt;&gt; 2021-11-14  NaN  NaN\n    &gt;&gt;&gt; 2021-11-15  NaN  NaN\n    &gt;&gt;&gt; 2021-11-16  NaN  NaN\n    &gt;&gt;&gt; 2021-11-17  NaN  NaN\n    &gt;&gt;&gt; 2021-11-18  2.0  6.0\n\n    with ip_frac set to 0.5, 50% of NaN's will be linearly\n    interpolated while the rest will back filled.\n\n    &gt;&gt;&gt;              a      b\n    &gt;&gt;&gt; 2021-11-13  1.00  4.00  &lt;&lt; original value --------\n    &gt;&gt;&gt; 2021-11-14  1.33  4.67                            |\n    &gt;&gt;&gt; 2021-11-15  1.67  5.33                            |  50% linearly\n    &gt;&gt;&gt; 2021-11-16  2.00  6.00  &lt;- linear interpolation   |  interpolated\n    &gt;&gt;&gt; 2021-11-17  2.00  6.00      upto here             |  rest are filled.\n    &gt;&gt;&gt; 2021-11-18  2.00  6.00  &lt;&lt; original value---------\n\n    This adds some stability in the barChartRace\n    and reduces constantly shaking of bars.\n</code></pre>"},{"location":"reference/datafiers/datafier/#pynimate.datafier.Datafier.add_var","title":"<code>add_var(row_var=None, col_var=None)</code>","text":"<p>Adds additional variables to the data, both row and column wise.</p> <p>Row wise data format: The index should be equal to that of the actual data. <pre><code>    time  leap_year col2   ...\n    2012    yes      0\n    2013    no       3\n</code></pre> Column wise data format: The index should be equal to the columns of the actual data. <pre><code>    index  continent   col2 ...\n    ind    Asia         0\n    usa    N America    3\n    jap    Asia         2\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>row_var</code> <code>pd.DataFrame</code> <p>Dataframe containing variables related to time, by default None</p> <code>None</code> <code>col_var</code> <code>pd.DataFrame</code> <p>Dataframe containing variables related to columns, by default None</p> <code>None</code>"},{"location":"reference/datafiers/datafier/#pynimate.datafier.Datafier.interpolate_even","title":"<code>interpolate_even(data, freq, method='linear')</code>","text":"<p>Interpolates the given dataframe according to the frequency</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>pd.DataFrame</code> <p>Dataframe contaning the data</p> required <code>freq</code> <code>str</code> <p>Interpolation frequency</p> required <code>method</code> <code>str</code> <p>Interpolation method, by default \"linear\"</p> <code>'linear'</code> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>Interpolated dataframe</p>"},{"location":"reference/datafiers/datafier/#pynimate.datafier.Datafier.get_prepared_data","title":"<code>get_prepared_data(data, ip_frac=0.5)</code>","text":"<p>Creates interpolated data and column ranks</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>pd.DataFrame</code> <p>Dataframe containing the data</p> required <code>ip_frac</code> <code>float</code> <p>Interpolation fraction, by default 0.5</p> <code>0.5</code> <p>Returns:</p> Type Description <code>tuple[pd.DataFrame, pd.DataFrame]</code> <p>Tuple containing the following data <pre><code>    pd.DataFrame: Interpolated data values\n    pd.DataFrame: Interpolated column ranks\n</code></pre></p>"},{"location":"reference/datafiers/datafier/#pynimate.datafier.Datafier.get_top_cols","title":"<code>get_top_cols()</code>","text":"<p>Selects columns where column_rank &lt; n_bars in any timestamp</p> <p>Returns:</p> Type Description <code>list[int]</code> <p>List of columns that will appear in the animation at least once</p>"},{"location":"reference/datafiers/datafier/#pynimate.datafier.Datafier.get_bar_colors","title":"<code>get_bar_colors()</code>","text":"<p>Generates bar (column) colors based on the given color palettes</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict containing column to color mapping</p>"},{"location":"reference/datafiers/line_datafier/","title":"LineDatafier","text":""},{"location":"reference/datafiers/line_datafier/#linedatafier_1","title":"LineDatafier","text":"<p>             Bases: <code>BaseDatafier</code></p> <p>Contains data preparation modules, which includes interpolation. data should be in this format where time is set to index <pre><code>    Example:\n    &gt;&gt;&gt; time  col1 col2 col3 ...\n    &gt;&gt;&gt; 2012   1    0    2\n    &gt;&gt;&gt; 2013   2    3    1\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>pd.DataFrame</code> <p>The data to be prepared, should be in this format where time is set to index</p> required <code>time_format</code> <code>str</code> <p>Index datetime format</p> required <code>ip_freq</code> <code>str</code> <p>Interpolation frequency</p> required"},{"location":"reference/datafiers/line_datafier/#pynimate.datafier.LineDatafier.prepare_data","title":"<code>prepare_data()</code>","text":"<p>Creates interpolated data</p> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>Interpolated data values</p>"}]}